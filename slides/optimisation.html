<section data-background-class="mandy">
  <h2>Optimisation des plans d'exécution</h2>
</section>

<section>
  <h3>En deux mots&nbsp;:</h3>
  <ul>
    <li>L'objectif est de <strong>réduire le temps d'execution</strong> sans changer le résultat&nbsp;;</li>
    <li>Au sein d'<em>Apache Spark</em>, le moteur d'execution s'appelle <em>Catalyst</em>&nbsp;;</li>
    <li>Deux familles d'optimiseur (<em>Rule Based Optimizer</em> et <em>Cost Based Optimizer</em>).</li>
  </ul>
  <aside class="notes">
Définition +

  </aside>
</section>

<section>
  <h3>Exemple d'optimisations dans <em>Apache Spark</em>&nbsp;:</h3>
  <ul>
    <li>Le <code>PushDownPredicate</code> pour filter le plus rapidement possible&nbsp;;</li>
    <li>Le <code>ColumnPruning</code> pour ignorer les colonnes inutiles lors d'un <code>SELECT *</code>&nbsp;;</li>
    <li>Le <code>CombineFilters</code> qui assemble deux filtres avec un <code>AND</code>. </li>
  </ul>
</section>

<section>
  <img src="./images/catalystExample.png" style="background:none; border:none; box-shadow:none;"/>
</section>

<section>
  <h3>Comment appliquer ces transformations au travers du code&nbsp;?</h3>
  <pre class="bigger-code scala"><code data-trim data-noescape>
trait TreeNode[Type <: TreeNode[Type]] {
  self: Type =>

  def children: Seq[Type] = ???

  def transform(pf: PartialFunction[Type, Type]): Type = ???

}
  </code></pre>
</section>

<section>
  <h3>Ce qu'il faut retenir&nbsp;:</h3>
  <ul>
    <li>le trait <code>TreeNode</code> nous aide à modéliser des structures en arbre immutables</li>
    <li>la methode <code>transform</code> permet de transformer l'arbre à l'aide de règles <em>ad-hoc</em></li>
    <li>le <em>Pattern Matching</em> et les <em>Partial Functions</em> permettent d'avoir une syntaxe simple et claire lors de la définition de ces règles</li>
  </ul>
</section>

<section>
  <h3>Implémentation du <code>CombineFilters</code>&nbsp;:</h3>
  <pre class="bigger-code scala"><code data-trim data-noescape>
object CombineFilters extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case Filter(exp1, Filter(exp2, grandChild)) =>
          Filter(And(exp1, exp2), grandChild)
  }
}
  </code></pre>
</section>

<section>
  <h3>Oui, mais&hellip;</h3>
  <div>
    <div class="left-column">
      <pre class="bigger-code java"><code data-trim data-noescape>
while(rows.hasNext()) {
  Row currentRow = rows.next();
  if(currentRow
      .get("age") > 18)
    return currentRow
      .get("name");
}
      </code></pre>
    </div>
    <div class="right-column">
      <pre class="bigger-code scala"><code data-trim data-noescape>
Project("name",
  Filter(
    Expression("age",
      greaterThan(18)),
    CsvScan("people.csv")
  )
)
      </code></pre>
    </div>
  </div>
  <div style="clear: both;">
    <p>&hellip;Ecrire du code spécifique reste plus performant&nbsp;!</p>
  </div>
  <aside class="notes">
Mouais... M O U A I S... TU TE FOUTERAIS PAS UN DE MA GUEULE ??
  </aside>
</section>

<section>
  <h3>Une sombre histoire de <em>JIT</em>&nbsp;:</h3>
  <ul>
    <li>Un opérateur 	&rArr; une implémentation du <em>Trait</em> <code>PhysicalPlan</code>&nbsp;;</li>
    <li>Invoquer la méthode <code>execute(...)</code> 	&rArr; Appel à une fonction virtuelle&nbsp;;</li>
    <li>Trop d'implémentation &rArr; On est dans le cas <em>Megamorphic</em>&nbsp;;</li>
    <li class="fragment">On casse le <em>Pipelining</em>. </li>
  </ul>
  <p class="fragment">Pour plus de détails&nbsp;: <a href="http://insightfullogic.com/2014/May/12/fast-and-megamorphic-what-influences-method-invoca/">Too Fast, Too Megamorphic: what influences method call performance in Java?</a>. </p>
</section>
