<section>
  <h2>Optimisation</h2>
  <p>En deux mots&nbsp;:</p>
  <ul>
    <li>L'objectif est de <strong>réduire le temps d'execution</strong> sans changer le résultat&nbsp;;</li>
    <li>Au sein d'<em>Apache Spark</em>, le moteur d'execution s'appelle <em>Catalyst</em>&nbsp;;</li>
    <li>Deux familles d'optimiseur (<em>Rule Based Optimizer</em> et <em>Cost Based Optimizer</em>).</li>
  </ul>
  <aside class="notes">
Définition +

  </aside>
</section>

<section>
  <h3>Example d'optimisations dans <em>Apache Spark</em>&nbsp;:</h3>
  <ul>
    <li>Le <code>PushDownPredicate</code> pour filter le plus rapidement possible&nbsp;</li>
    <li>Le <code>ColumnPruning</code> pour ignorer les colonnes inutiles lors d'un <code>SELECT *</code>&nbsp;;</li>
    <li>Le <code>CombineFilters</code> qui assemble deux filtres avec un <code>AND</code>. </li>
  </ul>
</section>

<section>
  <img src="./images/catalystExample.png" style="background:none; border:none; box-shadow:none;"/>
</section>

<section>
  <h3>Comment appliquer ces transformations au travers du code&nbsp;?</h3>
  <pre class="bigger-code scala"><code data-trim data-noescape>
trait TreeNode[Type <: TreeNode[Type]] {
  self: Type =>

  def children: Seq[Type] = ???

  def transform(pf: PartialFunction[Type, Type]): Type = ???

}
  </code></pre>
</section>

<section>
  <h3>Ce qu'il faut retenir&nbsp;:</h3>
  <ul>
    <li>le trait <code>TreeNode</code> nous aide à modéliser des structures en arbre immutables</li>
    <li>la methode <code>transform</code> permet de transformer l'arbre à l'aide de règles <em>ad-hoc</em></li>
    <li>le <em>Pattern Matching</em> et les <em>Partial Functions</em> permettent d'avoir une syntaxe simple et claire lors de la définition de ces règles</li>
  </ul>
</section>

<section>
  <h3>Implémentation du <code>CombineFilters</code></h3>
  <pre class="bigger-code scala"><code data-trim data-noescape>
object CombineFilters extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case Filter(exp1, Filter(exp2, grandChild)) =>
          Filter(And(exp1, exp2), grandChild)
  }
}
  </code></pre>
</section>

<section>
  <h3>C'est bien, mais&hellip;</h3>
  <ul>
    <li>Un opérateur &harr; Une classe&nbsp;;</li>
    <li>Une classe &harr; Un appel à une fonction virtuelle&hellip;</li>
  </ul>
  <p class="fragment">On perd le pipelining&nbsp;!</p>
</section>

<section>
  <h3>Et si on l'écrivait à la main&hellip;</h3>
  <div>
    <div class="left-column">
      <pre class="bigger-code java"><code data-trim data-noescape>
while(rows.hasNext()) {
  Row currentRow = rows.next();
  if(currentRow
      .get("age") > 18)
    return currentRow
      .get("name");
}
      </code></pre>
    </div>
    <div class="right-column">
      <pre class="bigger-code scala"><code data-trim data-noescape>
Project("name",
  Filter(
    Expression("age",
      greaterThan(18)),
    CsvScan("people.csv")
  )
)
      </code></pre>
    </div>
  </div>
  <div style="clear: both;">
    <p>&hellip;Ça serait beaucoup plus performant&nbsp;!</p>
  </div>
  <aside class="notes">
Mouais... M O U A I S... TU TE FOUTERAIS PAS UN DE MA GUEULE ??
  </aside>
</section>
