<section>
  <h2>Définition</h2>
  <ul>
    <li>
      <p>Invariance du résultat de l'execution</p>
    </li>
    <li>
      <p>Amélioration du temps d'execution de la requête</p>
    </li>
    <li>
      <p>Deux stratégies : </p>
      <ul>
        <li><em>Cost Based Optimizer</em></li>
        <li><em>Rule Based Optimizer</em></li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2>Rule Based Optimizer</h2>
  <pre class="bigger-code scala"><code data-trim data-noescape>
type Rule[P <: Plan[P]] = (P => P)
  </code></pre>
  <pre class="bigger-code scala"><code data-trim data-noescape>
trait PlanOptimizer[P <: Plan[P]] {

  def rules: Seq[Rule[P]]

  private def applyRules(plan: P): P = {
    rules.foldLeft(plan) { (plan, rule) =>
      rule(plan)
    }
  }

  def optimizePlan(plan: P): P = {
    Function.chain(Seq.fill(MaxIterations)(applyRules))(plan)
  }
}
  </code></pre>
</section>

<section>
  <h2>Réduction des les filtres</h2>
  <pre class="bigger-code scala"><code data-trim data-noescape>
object CollapseFilters extends Rule[PhysicalPlan] {

  override def apply(physicalPlan: PhysicalPlan) = {
    physicalPlan.transformDown {
      case Filter(Filter(child, oneExpr), otherExpr) =>
        Filter(child, e.And(oneExpr, otherExpr))
      }
    }
  }

}
  </pre></code>
</section>

<section>
  <h2>Un <em>Hash Join</em> au lieu d'un <em>Nesed Loop</em></h2>
  <pre class="bigger-code scala"><code data-trim data-noescape>
object UseHashJoin extends Rule[PhysicalPlan] with Logging {

  override def apply(physicalPlan: PhysicalPlan) = {
    physicalPlan.transformDown {
      case NestedLoopJoin(left, right, filter: e.Equal) =>
        HashJoin(left, right, filter)
    }
  }

}
  </code></pre>
</section>

<section>
  <h2>De nombreuses optimisations possibles</h2>
  <ul>
    <li><em>Predicate Pushdown</em></li>
    <li><em>Column Pruning</em></li>
    <li class="fragment">Génération de code</li>
  </ul>
</section>
