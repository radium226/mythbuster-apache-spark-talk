<section data-background-class="mantis" data-speaker="adrien">
  <h2>Génération de code et exécution</h2>
</section>

<section data-speaker="adrien">
  <h3>De quoi parle-t-on exactement ?</h3>
  <ul>
    <li>Compiler un code <strong>pendant l'exécution</strong>&nbsp;;</li>
    <li>Partir d'un <code>String</code> pour récupérer une <code>Class[_]</code>&nbsp;;</li>
  </ul>
  <pre class="bigger-code scala fragment"><code data-trim data-noescape>
def compile(code: String): Class[_] = ???
  </code></pre>
  <p class="fragment">Essayons !</p>
</section>

<section data-speaker="adrien">
  <img src="./images/compileJava.png" style="background:none; border:none; box-shadow:none;"/>
</section>

<section data-speaker="adrien">
  <pre class="bigger-code scala"><code data-trim data-noescape>
val javaClassCode : String =
    """public class GeneratedTalker {
      |
      | public String talk() {
      |   return "Hello, World! ";
      | }
      |
      |}
      |
    """.stripMargin
  </code></pre>
  <pre class="bigger-code scala fragment"><code data-trim data-noescape>
import sys.process._

Seq(
  "javac",
  "-d", "/tmp/generated-sources",
  "/tmp/generated-classes"
) !
  </code></pre>
  <pre class="bigger-code scala fragment"><code data-trim data-noescape>
val classLoader = new URLClassLoader("/tmp/generated-classes")
  </code></pre>
  <aside class="notes">
Bien expliquer qu'il n'y a rien de compliqué : il s'agit juste d'appeler un
process externe exactement comme si l'on lançait la commande depuis le Terminal
  </aside>
</section>

<section data-speaker="adrien">
  <pre class="bigger-code scala"><code data-trim data-noescape>
val myTalker = classLoader
  .loadClass("GeneratedTalker")
  .newInstance()
myTalker.talk()
  </code></pre>
  <pre class="bigger-code scala fragment"><code data-trim data-noescape>
// Cannot resolve symbol talk
  </code></pre>
</section>

<section data-speaker="adrien">
  <h3>Ouch! </h3>
  <p>Le type de <code>myTalker</code> n'est pas défini à la compilation !</p>
  <p>Il nous faut un <strong>pont</strong> entre le <em>Compile Time</em> et le <em>Run Time</em>&hellip; </p>
  <pre class="bigger-code java fragment"><code data-trim data-noescape>
public interface Talker {
    String talk();
}
  </code></pre>
  <aside class="notes">
    Pourquoi Java ? On a voulu faire comme Spark : c'est plus rapide à compiler, et en plus avec Janino, c'est stylé parce que c'est tout en mémoire.
  </aside>
</section>

<section data-speaker="adrien">
  <pre class="bigger-code scala"><code data-trim data-noescape>
  val javaClassCode =
    """public class GeneratedTalker implements Talker {
      |
      | @Override
      | public String talk() {
      |   return "Hello, World! ";
      | }
      |
      |}
      |
    """.stripMargin
  </code></pre>
  <pre class="bigger-code scala fragment"><code data-trim data-noescape>
val myTalker: Talker = classLoader
  .loadClass("GeneratedTalker")
  .newInstance()
  .asInstanceOf[Talker]
  </code></pre>
  <pre class="bigger-code scala fragment"><code data-trim data-noescape>
println(myTalker.talk())
// "Hello World !"
  </code></pre>
</section>

<section data-speaker="adrien">
  <h3>Du côté d'<em>Apache Spark</em>&nbsp;? </h3>
  <img src="./images/janino.png" />
  <p class="fragment">On fait la même chose... Mais en mémoire !</p>
  <aside class="notes">
    Bon bah c'est super, on sait générer du code... Et maintenant, on fait quoi ?
  </aside>
</section>

<section data-speaker="adrien">
  <img src="./images/so-what-2.png" />
  <aside class="notes">
    Bon bah c'est super, on sait générer du code... Et maintenant, on fait quoi ?
  </aside>
</section>
