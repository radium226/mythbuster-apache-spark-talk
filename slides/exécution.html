<section data-background-class="saffron-mango" data-talker="adrien">
  <h2>Exécution d'un AST</h2>
</section>

<section data-speaker="adrien">
  <h2>Exécution de la requête SQL</h2>
  <p>Deux étapes&nbsp;</p>
  <img src="./images/parsing_planning_optimisations.png" />
</section>

<section data-speaker="adrien">
  <h3>Plan d'execution logique</h3>
  <p>Par quelles étapes va-t-on passer pour évaluer l'AST&nbsp;?</p>
  <pre class="bigger-code scala"><code data-trim data-noescape>
sealed trait LogicalPlan
  </code></pre>
  <aside class="notes">
    Avec Spark, tu peux faire des jointures entre des sources de données hétérogène. <br />
    D'un point de vue logique, tu fais des jointures entre table, mais d'un point de vue physique, tu vas faire une jointure entre CsvTable et une JdbcTable
    On en reparlera plus tard, mais un join logique peut-être un hash Join ou un nested loop (suivant l'environnemtn dans lequel tu executes)
    Le plan d'execution logique, il ne permet pas d'executer, c'est juste une vision algébrique de ta requête (c'est vraiment un plan)
    Le plan physique, c'est vraiment l'execution (le marteau piqueur, celui qui rentre dans le dur)
    Ça n'est absolument pas spécifique à Spark, c'est commun à toutes les base de données (Oracle, etc.)
  </aside>
</section>

<section data-speaker="adrien">
  <pre class="bigger-code scala"><code data-trim data-noescape>
case class Projection(
  child: LogicalPlan, expression: Seq[Expression]
) extends LogicalPlan

case class Join(
  leftChild: LogicalPlan, rightChild: LogicalPlan,
  expression: BinaryOperation
) extends LogicalPlan

case class Filter(
  child: LogicalPlan,
  expression: Expression
) extends LogicalPlan

// ...
  </code></pre>
  <p class="fragment">Purement déclaratif, toujours pas d'execution !</p>
</section>

<section data-speaker="adrien">
  <h3>Plan d'exécution physique</h3>
  <p>Maintenant que l'on sait par quelles étapes passer, comment est-ce qu'on les exécute&nbsp;?</p>
</section>

<section data-speaker="adrien">
  <h4>Le <em>Volcano Model</em></h4>
  <p>Un peu d'histoire&nbsp;:</p>
  <ul>
    <li>Aussi appelé l'<em>Iterator Model</em>&nbsp;;</li>
    <li>La quasi-totalité des SGBDR s'appuie sur ce fonctionnement (PostgreSQL, Oracle, MySQL, etc.)&nbsp;;</li>
    <li>On <em>pull</em> la donnée&nbsp;;</li>
    <li>Un opérateur&nbsp;&harr;&nbsp;Une classe. </li>
  </ul>
  <pre class="bigger-code scala"><code data-trim data-noescape>
trait PhysicalPlan {

  def execute(): Iterator[Row]

}
  </code></pre>
</section>

<section data-speaker="adrien">
  <pre class="bigger-code scala"><code data-trim data-noescape>
case class Filter(
  child: PhysicalPlan, predicate: Predicate
) extends PhysicalPlan {

  override def execute() : Iterator[Row] = {
    child.execute()
      .filter(predicate.evaluate)
  }

}
  </code></pre>
  <pre class="bigger-code scala fragment"><code data-trim data-noescape>
case class CSVFileFullScan(
  csvFilePath: Path
) extends PhysicalPlan

case class NestedLoopJoin(
  leftChild: PhysicalPlan,
  rightChild: PhysicalPlan,
  predicate: Predicate
) extends PhysicalPlan

// Etc.
  </code></pre>
</section>

<section data-speaker="adrien">
  <img src="./images/volcano-model.png" />
  <aside class="notes">
    Image du volcano model <br />
    Classe qui s'imbriquent
  </aside>
</section>

<section data-speaker="adrien">
  <h3>Du côté d'<em>Apache Spark</em>&hellip;</h3>
  <p>C'est exactement la même chose, sauf que&hellip;</p>
  <pre class="bigger-code scala fragment"><code data-trim data-noescape>
final def execute(): <mark style="background-color: #ff79c2 ;">RDD[InternalRow]</mark> = executeQuery {
  if (isCanonicalizedPlan) {
    throw new IllegalStateException(
      "A canonicalized plan is not supposed to be executed."
    )
  }
  doExecute()
}
  </code></pre>
  <p class="fragment">&hellip;On retrouve l'abstraction <code>RDD[_]</code>&nbsp;!</p>
</section>

<section data-speaker="adrien">
  <pre class="bigger-code sql"><code data-trim data-noescape>
SELECT * FROM persons WHERE firstName = 'Adrien'
  </code></pre>
  <pre class="bigger-code fragment"><code data-trim data-noescape>
== Parsed Logical Plan ==
'Project [*]
+- 'Filter ('firstName = Adrien)
   +- 'UnresolvedRelation `persons`

== Analyzed Logical Plan ==
id: int, firstName: string, lastName: string
Project [id#4, firstName#5, lastName#6]
+- Filter (firstName#5 = Adrien)
   +- SubqueryAlias persons
      +- SerializeFromObject (...)
         +- ExternalRDD [obj#3]

== Optimized Logical Plan ==
Filter (isnotnull(firstName#5) && (firstName#5 = Adrien))
+- SerializeFromObject (...)
   +- ExternalRDD [obj#3]

== Physical Plan ==
*Filter (isnotnull(firstName#5) && (firstName#5 = Adrien))
+- *SerializeFromObject (...)
   +- Scan ExternalRDDScan[obj#3]
  </code></pre>
</section>
